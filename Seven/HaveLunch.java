package Seven;

import java.util.*;

public class HaveLunch {//初步理解集合
                        //大致思想：食堂每次随机进来人，但是只有一位食堂阿姨，学校穷
	                    //一次只能有一个同学能打到饭，但是食堂每次都会来未知的人，
	  //食堂很小，150个人就会饱满
	 //如果饱满，正在排队的同学继续吃饭，其余同学等下一次运行才有饭吃
	public static void main(String[] args) {
		Collection a = new ArrayList<Object>();//设定一个集合  这一行应该不用解释
		int j = 1,k = 1;//我给j的定义是一位同学1  2  3  打饭是有顺序的吧 不可能说
		//1同学打饭  3同学在他后面吧 那2同学岂不是和他打架了  然后  k的主要作用就是
		//一位同学打饭  然后就走  因为2打饭了 1 已经是吃完了 吃完就可以走了
		for (int i = 0; i < Math.random() * 10+1; i++) {
			a.add(j++);
		}//该段循环就是说有多少人  随机来人的  因为食堂啊 你也不可能控制多少人吧
		//然后j++就是1同学进去  2同学进去排队・・・・
		System.out.println("食堂来了" + a.size() + "人");//当一批人进去之后
		//这时候告诉我 食堂多少人啊   调用该集合的size方法就知道你add多少人了
		Iterator it = a.iterator();//遍历器  就是可以往后面走 跟链表类似但不一样
		System.out.println(it.next() + "号BOY打到了餐");
		//这时候  利用遍历器的next就是把第一位同学拿出来  然后他是集合元素 谁能接受呢  也只有
		//万物的父类  object能接受啦  object是所有类的父类 什么都可以收
		a.remove(k++);//他既然吃饭了 还需要排队嘛？当然是可以滚了，所以1同学就这样被赶出去了
		while (it.hasNext()) {//hasnext是判断集合里面还有没有数值  但是并不会走的  返回true or
			//false
			for (int i = 0; i < Math.random() * 10; i++) {
				a.add(j++);
			}		//这时候又要来人啦 因为有同学来排队嘛
			System.out.println("食堂还有"+a.size()+"人");//看看走了一个之后还有多少人	
			Iterator two = a.iterator();//为什么要重新这样呢  因为遍历器不能在输出后面的值  
			//经过调试 每一次加入新的元素都需要来重新遍历器一次  相当于刷新一次  毕竟来了新人啊
			//这个就不同于链表啦    然后 1 同学已经走啦  所以开头的是2同学 觉得乱就再看一次  
			//相信你能看懂
			System.out.println((Object) two.next() + "号BOY打到了餐");//这时候肯定阿姨
			//又要给饭啦   虽然就一个阿姨  但是饭还是要吃的吧
			a.remove(k++);//2同学吃饭了就可以走啦
			//System.out.println("还有"+a.size()+"人");
			if (a.size() > 100) {//这个就是控制循环啊  毕竟前面还有while啊 
				//因为不知道每次多少人来 学校食堂我当他150人最大  所以大于100就要禁止来
				//人啦  毕竟你也不知道现在多少人在排队呢是吧
				System.out.println("食堂没饭了，回去上课");
				while (two.hasNext()) {
					//因为还有同学排队啊  肯定要给他们继续吃饭吧 不然不就白排队了
					//用官方语言来说 将集合中的元素  一个一个的数出来  
					Iterator three = a.iterator();//当然  因为用了一个hasnext  
					                               // 当然得刷新一次
					System.out.println((Object) three.next() + "号BOY打到了餐");
					//就输出一位
					a.remove(k++);//输出了就删除它 因为它打到饭了  然后就继续输出
				}//如果没有100个元素 还可以排队是吧 然后就继续排队 继续while啊  
				//仔细理解一下思想  看看能不能懂  
				//然后 到了100的警告值 输出完剩下的  break结束循环就好啦
				//还算比较好的解释吧 我想了很多话  应该会好理解一点了 
				//再试试 抱着点耐心啊  加油！！！！
				//break;
			}
		}
	}
}
